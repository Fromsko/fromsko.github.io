# è½¯åˆ é™¤æœºåˆ¶

# è½¯åˆ é™¤æœºåˆ¶

> ä»‹ç»ä¸€ä¸‹ Gorm çš„è½¯åˆ é™¤æŠ€æœ¯ï¼Œè®²è§£ä¸€ä¸‹ä¸ Mybatis çš„ä¸€ä¸ªåŒºåˆ«ï¼Œå’Œä¼ ç»Ÿ MySQL çš„å·®å¼‚ã€‚

### ğŸ§¾ GORM è½¯åˆ é™¤è¯¦è§£

åœ¨æ•°æ®åº“å¼€å‘ä¸­ï¼Œ**è½¯åˆ é™¤ï¼ˆSoft Deleteï¼‰** æ˜¯ä¸€ç§é€»è¾‘ä¸Šâ€œåˆ é™¤â€æ•°æ®çš„æ–¹å¼ï¼Œè€Œä¸æ˜¯ç‰©ç†ä¸Šä»è¡¨ä¸­ç§»é™¤è®°å½•ã€‚GORM åŸç”Ÿæ”¯æŒè½¯åˆ é™¤åŠŸèƒ½ï¼Œé€šè¿‡ `gorm.DeletedAt` å­—æ®µå®ç°ã€‚

---

## ğŸ” ä»€ä¹ˆæ˜¯è½¯åˆ é™¤ï¼Ÿ

è½¯åˆ é™¤çš„æœ¬è´¨æ˜¯åœ¨æ•°æ®è¡¨ä¸­æ·»åŠ ä¸€ä¸ªå­—æ®µï¼ˆå¦‚ `deleted_at TIMESTAMP`ï¼‰ï¼Œå½“æ‰§è¡Œåˆ é™¤æ“ä½œæ—¶ï¼Œå¹¶ä¸æ˜¯çœŸæ­£åœ°å°†è®°å½•ä»æ•°æ®åº“ä¸­åˆ é™¤ï¼Œè€Œæ˜¯è®¾ç½®è¯¥å­—æ®µä¸ºå½“å‰æ—¶é—´æˆ³ã€‚åç»­æŸ¥è¯¢æ—¶è‡ªåŠ¨è¿‡æ»¤æ‰è¿™äº›æ ‡è®°ä¸ºå·²åˆ é™¤çš„è®°å½•ã€‚

> è½¯åˆ é™¤å¸¸ç”¨äºéœ€è¦ä¿ç•™å†å²æ•°æ®ã€å®¡è®¡æ—¥å¿—æˆ–é˜²æ­¢è¯¯åˆ çš„åœºæ™¯ã€‚

---

## ğŸ’¡ GORM ä¸­çš„è½¯åˆ é™¤æœºåˆ¶

### 1. å®šä¹‰è½¯åˆ é™¤å­—æ®µ

åœ¨ç»“æ„ä½“ä¸­åŠ å…¥ `DeletedAt` å­—æ®µï¼š

```go
type User struct {
    ID        uint
    Name      string
    DeletedAt gorm.DeletedAt `gorm:"index"` // å¯ç”¨è½¯åˆ é™¤
}
```

GORM ä½¿ç”¨ `*time.Time`â€‹ æˆ– `gorm.DeletedAt` ç±»å‹æ¥è¯†åˆ«æ˜¯å¦å¯ç”¨è½¯åˆ é™¤åŠŸèƒ½ã€‚

### 2. åˆ é™¤æ“ä½œ

ä½¿ç”¨æ ‡å‡†çš„ `Delete()` æ–¹æ³•å³å¯è¿›è¡Œè½¯åˆ é™¤ï¼š

```go
db.Delete(&user)
// å®é™… SQL: UPDATE users SET deleted_at = NOW() WHERE id = ?
```

### 3. æŸ¥è¯¢å¿½ç•¥è½¯åˆ é™¤è®°å½•

é»˜è®¤æƒ…å†µä¸‹ï¼ŒGORM çš„ `Find`â€‹, `First`â€‹ ç­‰æ–¹æ³•ä¼šè‡ªåŠ¨å¿½ç•¥ `deleted_at IS NOT NULL` çš„è®°å½•ã€‚

### 4. æŸ¥è¯¢è½¯åˆ é™¤è®°å½•

å¦‚æœéœ€è¦æŸ¥çœ‹è¢«è½¯åˆ é™¤çš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ `.Unscoped()`ï¼š

```go
var user User
db.Unscoped().Where("id = ?", 1).First(&user)
```

### 5. æ¢å¤è½¯åˆ é™¤è®°å½•

åŒæ ·ä½¿ç”¨ `.Unscoped()` ä¿®æ”¹çŠ¶æ€ï¼š

```go
db.Unscoped().Model(&user).Update("deleted_at", nil)
```

---

## âš–ï¸ GORM è½¯åˆ é™¤ vs MyBatis è½¯åˆ é™¤

| ç‰¹æ€§                 | GORM                          | MyBatis                            |
| -------------------- | ----------------------------- | ---------------------------------- |
| **å†…ç½®æ”¯æŒ**         | âœ… åŸç”Ÿæ”¯æŒ                   | âŒ éœ€æ‰‹åŠ¨å®ç°                      |
| **è¯­æ³•ç®€æ´ç¨‹åº¦**     | é«˜ï¼ˆç»“æ„ä½“+æ ‡ç­¾ï¼‰             | ä½ï¼ˆéœ€æ‰‹å†™ SQL åˆ¤æ–­ `is_deleted`ï¼‰ |
| **è‡ªåŠ¨è¿‡æ»¤é€»è¾‘åˆ é™¤** | âœ… é»˜è®¤è¿‡æ»¤                   | âŒ éœ€æ‰‹åŠ¨åŠ æ¡ä»¶                    |
| **æ¢å¤é€»è¾‘åˆ é™¤**     | ç®€å•ï¼ˆæ›´æ–° DeletedAt ä¸º nilï¼‰ | æ‰‹åŠ¨ä¿®æ”¹å­—æ®µå€¼                     |
| **æ€§èƒ½å½±å“**         | å°ï¼ˆç´¢å¼•ä¼˜åŒ– + å•ä¸€å­—æ®µï¼‰     | å¯èƒ½é«˜ï¼ˆä¾èµ–å­—æ®µåˆ¤æ–­ï¼‰             |

ğŸ“Œ **ç»“è®ºï¼š**

- GORM å¯¹è½¯åˆ é™¤æ˜¯å°è£…å®Œæ•´çš„ ORM å±‚è§£å†³æ–¹æ¡ˆã€‚
- MyBatis æ›´çµæ´»ä½†éœ€è¦å¼€å‘è€…è‡ªè¡Œç»´æŠ¤é€»è¾‘åˆ é™¤å­—æ®µå’ŒæŸ¥è¯¢æ¡ä»¶ã€‚

---

## ğŸ”„ GORM è½¯åˆ é™¤ä¸ä¼ ç»Ÿ MySQL ç‰©ç†åˆ é™¤å¯¹æ¯”

| ç»´åº¦             | è½¯åˆ é™¤ï¼ˆGORMï¼‰                           | ç‰©ç†åˆ é™¤ï¼ˆMySQL DELETEï¼‰         |
| ---------------- | ---------------------------------------- | -------------------------------- |
| **æ•°æ®æ˜¯å¦ä¸¢å¤±** | âŒ ä¸ä¸¢å¤±                                | âœ… æ•°æ®æ°¸ä¹…ä¸¢å¤±                  |
| **å¯æ¢å¤æ€§**     | âœ… å¯ä»¥é€šè¿‡è®¾ç½® `deleted_at = NULL` æ¢å¤ | âŒ å¾ˆéš¾æ¢å¤ï¼ˆé™¤éæœ‰å¤‡ä»½/binlogï¼‰ |
| **æŸ¥è¯¢æ•ˆç‡**     | å¯æ¥å—ï¼ˆå»ºç«‹ç´¢å¼•åï¼‰                     | æ›´å¿«                             |
| **å­˜å‚¨å ç”¨**     | æœ‰å†—ä½™æ•°æ®                               | ä¸å ç©ºé—´                         |
| **é€‚åˆåœºæ™¯**     | æ—¥å¿—ã€å®¡è®¡ã€ç”¨æˆ·æ³¨é”€ç­‰                   | ä¸´æ—¶æ•°æ®æ¸…ç†ã€åƒåœ¾å›æ”¶ç­‰         |

---

## ğŸ›  ç¤ºä¾‹ï¼šè½¯åˆ é™¤ä»£ç ç‰‡æ®µï¼ˆGORMï¼‰

```go
type Product struct {
    ID        uint
    Name      string
    Price     float64
    DeletedAt gorm.DeletedAt `gorm:"index"`
}

// åˆ›å»ºäº§å“
db.Create(&Product{Name: "iPhone", Price: 999})

// è½¯åˆ é™¤äº§å“
var product Product
db.First(&product, 1)
db.Delete(&product)

// æŸ¥çœ‹æ‰€æœ‰äº§å“ï¼ˆå«è½¯åˆ é™¤ï¼‰
var products []Product
db.Unscoped().Find(&products) // è¿”å›åŒ…æ‹¬ deleted_at != null çš„æ•°æ®

// æ¢å¤è½¯åˆ é™¤
db.Unscoped().Model(&product).Update("deleted_at", nil)
```

---

## ğŸ“Œ æ€»ç»“è¡¨æ ¼

| å¯¹æ¯”ç»´åº¦     | GORM è½¯åˆ é™¤                | MyBatis è½¯åˆ é™¤     | MySQL ç‰©ç†åˆ é™¤     |
| ------------ | -------------------------- | ------------------ | ------------------ |
| æ˜¯å¦åŸç”Ÿæ”¯æŒ | âœ… æ˜¯                      | âŒ å¦              | âœ… æ˜¯              |
| å®ç°å¤æ‚åº¦   | ä½                         | é«˜                 | æä½               |
| æ•°æ®å¯æ¢å¤æ€§ | âœ… å¯æ¢å¤                  | âœ…ï¼ˆå–å†³äºå®ç°ï¼‰   | âŒ å‡ ä¹ä¸å¯é€†      |
| æŸ¥è¯¢æ•ˆç‡     | ä¸­ç­‰ï¼ˆå¸¦è¿‡æ»¤æ¡ä»¶ï¼‰         | ä¸­ç­‰ï¼ˆæ‰‹å†™æ¡ä»¶ï¼‰   | é«˜                 |
| å­˜å‚¨å¼€é”€     | æœ‰å†—ä½™                     | æœ‰å†—ä½™             | æ—                  |
| åœºæ™¯é€‚ç”¨     | å®¡è®¡ã€ç”¨æˆ·ç®¡ç†ã€æ—¥å¿—ç³»ç»Ÿç­‰ | è‡ªå®šä¹‰éœ€æ±‚å¼ºçš„é¡¹ç›® | æ— éœ€ä¿ç•™æ•°æ®çš„åœºæ™¯ |

---

## âœ… æ¨èå®è·µ

- åœ¨æ¶‰åŠé‡è¦ä¸šåŠ¡æ•°æ®çš„æ¨¡å‹ä¸­å¯ç”¨è½¯åˆ é™¤ï¼ˆå¦‚ç”¨æˆ·ã€è®¢å•ã€æ–‡ç« ç­‰ï¼‰ï¼›
- ç»“åˆ `.Unscoped()` æ–¹æ³•å®ç°æ¢å¤ã€ç»Ÿè®¡ç­‰åŠŸèƒ½ï¼›
- ä½¿ç”¨é’©å­å‡½æ•°ï¼ˆå¦‚ `BeforeDelete`ï¼‰è¿›è¡Œæƒé™æ£€æŸ¥æˆ–æ—¥å¿—è®°å½•ï¼›
- ä¸º `deleted_at` æ·»åŠ ç´¢å¼•ä»¥æé«˜æŸ¥è¯¢æ€§èƒ½ï¼›
- å®šæœŸæ¸…ç†é•¿æœŸæœªä½¿ç”¨çš„è½¯åˆ é™¤æ•°æ®ï¼ˆå½’æ¡£æˆ–ç‰©ç†åˆ é™¤ï¼‰ã€‚

---

å¦‚æœä½ è¿˜æƒ³äº†è§£å¦‚ä½•ç»“åˆ Gin æ¡†æ¶å®ç° RESTful API çš„è½¯åˆ é™¤æ¥å£ã€æˆ–è€… GORM çš„å…¨å±€é’©å­åšç»Ÿä¸€è½¯åˆ é™¤å¤„ç†ç­–ç•¥ï¼Œæˆ‘ä¹Ÿå¯ä»¥ä¸ºä½ æ‰©å±•è®²è§£ ğŸ‘‡

â€

ç»“åˆ Gin æ¡†æ¶å®ç° RESTful API çš„è½¯åˆ é™¤æ¥å£ã€æˆ–è€… GORM çš„å…¨å±€é’©å­åšç»Ÿä¸€è½¯åˆ é™¤å¤„ç†ç­–ç•¥, Gorm-SQLite

å¥½çš„ï¼æˆ‘ä»¬å°†ç»“åˆ **GORM + SQLite + Gin æ¡†æ¶**ï¼Œå®ç°ä¸€ä¸ªå®Œæ•´çš„ RESTful API æ¥å£ç³»ç»Ÿï¼Œæ”¯æŒï¼š

- ç”¨æˆ·æ³¨å†Œã€ç™»å½•ï¼ˆå¸¦æƒé™åŒºåˆ†ï¼‰
- ç”¨æˆ·åˆ—è¡¨è·å–
- è½¯åˆ é™¤åŠŸèƒ½ï¼ˆé€»è¾‘åˆ é™¤ï¼‰
- ä½¿ç”¨ GORM çš„é’©å­å‡½æ•°ç»Ÿä¸€å¤„ç†è½¯åˆ é™¤é€»è¾‘å’Œæ—¥å¿—è®°å½•

---

## ğŸ§± æŠ€æœ¯æ ˆ

| å·¥å…·/åº“        | ç‰ˆæœ¬/ç”¨é€”è¯´æ˜            |
| -------------- | ------------------------ |
| Go             | 1.20+                    |
| GORM           | ORM æ“ä½œæ•°æ®åº“           |
| SQLite         | è½»é‡çº§æ•°æ®åº“ç”¨äºæœ¬åœ°æµ‹è¯• |
| Gin            | æ„å»º RESTful API         |
| bcrypt         | åŠ å¯†ç”¨æˆ·å¯†ç              |
| gorm.DeletedAt | å®ç°è½¯åˆ é™¤               |

---

## ğŸ“ ç›®å½•ç»“æ„ï¼ˆç®€åŒ–ï¼‰

```
.
â”œâ”€â”€ main.go
â”œâ”€â”€ go.mod
â”œâ”€â”€ models/
â”‚   â””â”€â”€ user.go
â”œâ”€â”€ handlers/
â”‚   â””â”€â”€ user.go
â””â”€â”€ middlewares/
    â””â”€â”€ auth.go
```

---

## ğŸ”§ ç¬¬ä¸€æ­¥ï¼šåˆå§‹åŒ–é¡¹ç›® & å®‰è£…ä¾èµ–

```bash
go mod init your_project_name
go get -u gorm.io/gorm gorm.io/driver/sqlite github.com/gin-gonic/gin golang.org/x/crypto/bcrypt
```

---

## ğŸ—‚ï¸ models/user.go

å®šä¹‰ç”¨æˆ·æ¨¡å‹ä¸è½¯åˆ é™¤å­—æ®µã€‚

```go
package models

import (
    "gorm.io/gorm"
)

type Role string

const (
    RoleUser   Role = "user"
    RoleAdmin  Role = "admin"
)

type User struct {
    ID        uint           `json:"id" gorm:"primaryKey"`
    Username  string         `json:"username" gorm:"unique"`
    Password  string         `json:"-"`
    Role      Role           `json:"role"`
    DeletedAt gorm.DeletedAt `json:"-" gorm:"index"` // å¯ç”¨è½¯åˆ é™¤
}
```

---

## ğŸª é’©å­å‡½æ•°ï¼šmodels/hooks.go

æˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸€ä¸ªå…¨å±€é’©å­ï¼Œåœ¨åˆ é™¤æ“ä½œå‰åšæƒé™æ£€æŸ¥æˆ–æ—¥å¿—è®°å½•ã€‚

```go
package models

import (
    "fmt"
    "gorm.io/gorm"
)

func RegisterHooks(db *gorm.DB) {
    db.Callback().Delete().Before("gorm:delete").Register("before_delete_log", func(tx *gorm.DB) {
        fmt.Println("å‡†å¤‡æ‰§è¡Œåˆ é™¤æ“ä½œ...")
    })

    db.Callback().Delete().After("gorm:delete").Register("after_delete_log", func(tx *gorm.DB) {
        fmt.Println("åˆ é™¤æ“ä½œå·²å®Œæˆã€‚")
    })
}
```

---

## ğŸ“¡ handlers/user.go

ç¼–å†™ Gin å¤„ç†æ¥å£ã€‚

```go
package handlers

import (
    "net/http"
    "your_project_name/models"
    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

var db *gorm.DB

func SetDB(database *gorm.DB) {
    db = database
}

// æ³¨å†Œç”¨æˆ·
func Register(c *gin.Context) {
    var user models.User
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
    user.Password = string(hashedPassword)
    user.Role = models.RoleUser

    if err := db.Create(&user).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "æ³¨å†Œå¤±è´¥"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "æ³¨å†ŒæˆåŠŸ"})
}

// ç™»å½•æ¥å£
func Login(c *gin.Context) {
    var input struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }

    if err := c.ShouldBindJSON(&input); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    var user models.User
    if err := db.Where("username = ?", input.Username).First(&user).Error; err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"})
        return
    }

    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "ç™»å½•æˆåŠŸ", "role": user.Role})
}

// è·å–æ‰€æœ‰ç”¨æˆ·ï¼ˆæ’é™¤å·²è½¯åˆ é™¤ï¼‰
func GetUsers(c *gin.Context) {
    var users []models.User
    db.Find(&users)
    c.JSON(http.StatusOK, users)
}

// åˆ é™¤ç”¨æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰
func DeleteUser(c *gin.Context) {
    id := c.Param("id")
    if err := db.Delete(&models.User{}, id).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "åˆ é™¤å¤±è´¥"})
        return
    }
    c.JSON(http.StatusOK, gin.H{"message": "åˆ é™¤æˆåŠŸ"})
}

// æŸ¥çœ‹è¢«è½¯åˆ é™¤çš„ç”¨æˆ·
func GetDeletedUsers(c *gin.Context) {
    var users []models.User
    db.Unscoped().Where("deleted_at IS NOT NULL", "").Find(&users)
    c.JSON(http.StatusOK, users)
}
```

---

## ğŸ§­ main.go

æ•´åˆ Gin å’Œ GORMã€‚

```go
package main

import (
    "fmt"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "github.com/gin-gonic/gin"
    "your_project_name/handlers"
    "your_project_name/models"
)

func main() {
    // åˆå§‹åŒ– SQLite æ•°æ®åº“
    db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    if err != nil {
        panic("è¿æ¥æ•°æ®åº“å¤±è´¥")
    }

    // è‡ªåŠ¨è¿ç§»
    db.AutoMigrate(&models.User{})

    // æ³¨å†Œé’©å­
    models.RegisterHooks(db)

    // åˆå§‹åŒ– handlers DB
    handlers.SetDB(db)

    // åˆå§‹åŒ– Gin
    r := gin.Default()

    // è·¯ç”±ç»„
    api := r.Group("/api")
    {
        api.POST("/register", handlers.Register)
        api.POST("/login", handlers.Login)

        api.GET("/users", handlers.GetUsers)
        api.DELETE("/users/:id", handlers.DeleteUser)
        api.GET("/deleted-users", handlers.GetDeletedUsers)
    }

    fmt.Println("æœåŠ¡å¯åŠ¨äº http://localhost:8080")
    r.Run(":8080")
}
```

---

## âœ… æµ‹è¯•æ¥å£

ä½¿ç”¨ Postman æˆ– curl è¿›è¡Œæµ‹è¯•ï¼š

### æ³¨å†Œç”¨æˆ·

```bash
POST /api/register
{
  "username": "alice",
  "password": "123456"
}
```

### ç™»å½•

```bash
POST /api/login
{
  "username": "alice",
  "password": "123456"
}
```

### è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆä¸åŒ…æ‹¬è½¯åˆ é™¤ï¼‰

```bash
GET /api/users
```

### è·å–è¢«è½¯åˆ é™¤çš„ç”¨æˆ·

```bash
GET /api/deleted-users
```

### åˆ é™¤ç”¨æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰

```bash
DELETE /api/users/1
```

---

## ğŸ”„ è¡¥å……ï¼šæ¢å¤è½¯åˆ é™¤ç”¨æˆ·

ä½ å¯ä»¥æ‰©å±•æ¥å£å®ç°æ¢å¤è½¯åˆ é™¤åŠŸèƒ½ï¼š

```go
func RestoreUser(c *gin.Context) {
    id := c.Param("id")
    db.Unscoped().Model(&models.User{}).Where("id = ?", id).Update("deleted_at", nil)
    c.JSON(http.StatusOK, gin.H{"message": "æ¢å¤æˆåŠŸ"})
}
```

ç„¶åæ·»åŠ è·¯ç”±ï¼š

```go
api.PUT("/restore/users/:id", handlers.RestoreUser)
```

---

## ğŸ¯ æ€»ç»“

| åŠŸèƒ½                   | æ˜¯å¦æ”¯æŒ     | è¯´æ˜                             |
| ---------------------- | ------------ | -------------------------------- |
| è½¯åˆ é™¤                 | âœ…           | ä½¿ç”¨ `gorm.DeletedAt`            |
| é’©å­å‡½æ•°               | âœ…           | åœ¨åˆ é™¤å‰åè¾“å‡ºæ—¥å¿—               |
| æƒé™æ§åˆ¶ï¼ˆç¤ºä¾‹ä¸­ç®€å•ï¼‰ | âœ…ï¼ˆå¯æ‰©å±•ï¼‰ | å¯ä»¥åŸºäº role å­—æ®µåˆ¤æ–­æ˜¯å¦ç®¡ç†å‘˜ |
| RESTful API            | âœ…           | ä½¿ç”¨ Gin æ„å»ºæ¥å£                |
| ç”¨æˆ·ç®¡ç† CRUD          | âœ…           | æ”¯æŒæ³¨å†Œã€æŸ¥è¯¢ã€è½¯åˆ é™¤ã€æ¢å¤     |
| æ•°æ®åº“å¼•æ“             | SQLite       | ç®€å•è½»é‡ï¼Œé€‚åˆå¼€å‘æµ‹è¯•           |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

1. **JWT Token ç™»å½•è®¤è¯**
2. **ä¸­é—´ä»¶æƒé™æ ¡éªŒ**
3. **ä½¿ç”¨ Redis ç¼“å­˜ç”¨æˆ·ä¿¡æ¯**
4. **éƒ¨ç½² MySQL æ›¿æ¢ SQLite**
5. **åŠ å…¥ Swagger æ–‡æ¡£**
6. **å•å…ƒæµ‹è¯•è¦†ç›–**

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­ä¸ºä½ å°è£… JWT è®¤è¯æ¨¡å—ã€æˆ–è€…æ„å»ºå®Œæ•´çš„ RBAC æƒé™ç³»ç»Ÿï¼ˆè§’è‰²-æƒé™å…³è”è¡¨ï¼‰ï¼Œä¹Ÿå¯ä»¥ç»§ç»­æé—® ğŸ‘‡

â€

1. **JWT Token ç™»å½•è®¤è¯**
2. **ä¸­é—´ä»¶æƒé™æ ¡éªŒ**
3. MySQL æ›¿æ¢ SQLite
4. ä¼˜åŒ–ä¸€ä¸‹æ•´ä¸ªå¤„ç†æµç¨‹ï¼Œç¨å¾®å°è£…ä¸€ä¸‹æ•´ä¸ªå“åº”è¯·æ±‚ã€‚

å¥½çš„ï¼æˆ‘ä»¬å°†å¯¹å½“å‰é¡¹ç›®è¿›è¡Œ **åŠŸèƒ½å¢å¼ºå’Œç»“æ„ä¼˜åŒ–**ï¼ŒåŒ…æ‹¬ä»¥ä¸‹å››ä¸ªæ ¸å¿ƒæ‰©å±•ï¼š

---

## âœ… ç›®æ ‡

1. ğŸ§¾ ä½¿ç”¨ JWT å®ç°ç™»å½•è®¤è¯
2. ğŸ” æ·»åŠ ä¸­é—´ä»¶å®ç°æƒé™æ§åˆ¶ï¼ˆä»…ç®¡ç†å‘˜å¯åˆ é™¤ï¼‰
3. ğŸ›  å°†æ•°æ®åº“ä» SQLite æ›¿æ¢ä¸º MySQL
4. ğŸ“¦ å°è£…ç»Ÿä¸€çš„ API å“åº”æ ¼å¼

---

## ğŸ—‚ï¸ ä¼˜åŒ–åçš„ç›®å½•ç»“æ„

```
.
â”œâ”€â”€ main.go
â”œâ”€â”€ go.mod
â”œâ”€â”€ config/
â”‚   â””â”€â”€ db.go
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ user.go
â”‚   â””â”€â”€ hooks.go
â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ auth.go
â”‚   â””â”€â”€ user.go
â”œâ”€â”€ middlewares/
â”‚   â”œâ”€â”€ auth.go
â”‚   â””â”€â”€ role.go
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ response.go
â””â”€â”€ services/
    â””â”€â”€ jwt.go
```

---

## 1ï¸âƒ£ é…ç½®æ•°æ®åº“è¿æ¥ï¼ˆMySQLï¼‰

### `config/db.go`

```go
package config

import (
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

func ConnectDB() *gorm.DB {
    dsn := "root:password@tcp(127.0.0.1:3306)/mydb?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic("è¿æ¥æ•°æ®åº“å¤±è´¥")
    }

    return db
}
```

> âš ï¸ æ›¿æ¢ `dsn` ä¸­çš„ç”¨æˆ·åã€å¯†ç ã€æ•°æ®åº“åä¸ºä½ è‡ªå·±çš„ MySQL é…ç½®ã€‚

---

## 2ï¸âƒ£ ç”¨æˆ·æ¨¡å‹ä¸è½¯åˆ é™¤å­—æ®µ

### `models/user.go`

```go
package models

import (
    "gorm.io/gorm"
)

type Role string

const (
    RoleUser  Role = "user"
    RoleAdmin Role = "admin"
)

type User struct {
    ID       uint           `json:"id" gorm:"primaryKey"`
    Username string         `json:"username" gorm:"unique"`
    Password string         `json:"-"`
    Role     Role           `json:"role"`
    DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
}
```

---

## 3ï¸âƒ£ GORM è½¯åˆ é™¤é’©å­å‡½æ•°

### `models/hooks.go`

```go
package models

import (
    "fmt"
    "gorm.io/gorm"
)

func RegisterHooks(db *gorm.DB) {
    db.Callback().Delete().Before("gorm:delete").Register("before_delete_log", func(tx *gorm.DB) {
        fmt.Println("å‡†å¤‡æ‰§è¡Œåˆ é™¤æ“ä½œ...")
    })

    db.Callback().Delete().After("gorm:delete").Register("after_delete_log", func(tx *gorm.DB) {
        fmt.Println("åˆ é™¤æ“ä½œå·²å®Œæˆã€‚")
    })
}
```

---

## 4ï¸âƒ£ JWT ç™»å½•è®¤è¯æœåŠ¡

### `services/jwt.go`

```go
package services

import (
    "github.com/dgrijalva/jwt-go"
    "time"
)

var jwtKey = []byte("your-secret-key")

type Claims struct {
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.StandardClaims
}

func GenerateToken(username, role string) (string, error) {
    expirationTime := time.Now().Add(24 * time.Hour)
    claims := &Claims{
        Username: username,
        Role:     role,
        StandardClaims: jwt.StandardClaims{
            ExpiresAt: expirationTime.Unix(),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtKey)
}
```

---

## 5ï¸âƒ£ ç™»å½•æ¥å£å¤„ç†

### `handlers/auth.go`

```go
package handlers

import (
    "net/http"
    "your_project_name/models"
    "your_project_name/services"
    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

var db *gorm.DB

func SetDB(database *gorm.DB) {
    db = database
}

// ç™»å½•ç”Ÿæˆ Token
func Login(c *gin.Context) {
    var input struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }

    if err := c.ShouldBindJSON(&input); err != nil {
        utils.ErrorResponse(c, http.StatusBadRequest, err.Error())
        return
    }

    var user models.User
    if err := db.Where("username = ?", input.Username).First(&user).Error; err != nil {
        utils.ErrorResponse(c, http.StatusUnauthorized, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
        return
    }

    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
        utils.ErrorResponse(c, http.StatusUnauthorized, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
        return
    }

    token, _ := services.GenerateToken(user.Username, string(user.Role))
    utils.SuccessResponse(c, gin.H{"token": token})
}
```

---

## 6ï¸âƒ£ ä¸­é—´ä»¶ï¼šJWT è®¤è¯å’Œè§’è‰²æ ¡éªŒ

### `middlewares/auth.go`

```go
package middlewares

import (
    "github.com/dgrijalva/jwt-go"
    "github.com/gin-gonic/gin"
    "net/http"
    "strings"
    "your_project_name/services"
)

func AuthMiddleware(c *gin.Context) {
    authHeader := c.GetHeader("Authorization")
    if authHeader == "" {
        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "ç¼ºå°‘æˆæƒå¤´"})
        return
    }

    tokenString := strings.TrimPrefix(authHeader, "Bearer ")
    claims := &services.Claims{}

    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
        return services.JwtKey, nil
    })

    if err != nil || !token.Valid {
        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "æ— æ•ˆçš„ token"})
        return
    }

    c.Set("username", claims.Username)
    c.Set("role", claims.Role)
    c.Next()
}
```

### `middlewares/role.go`

```go
package middlewares

import "github.com/gin-gonic/gin"

func AdminOnly(c *gin.Context) {
    role, _ := c.Get("role")
    if role != "admin" {
        c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™è®¿é—®"})
        return
    }
    c.Next()
}
```

---

## 7ï¸âƒ£ ç»Ÿä¸€å“åº”å°è£…

### `utils/response.go`

```go
package utils

import "github.com/gin-gonic/gin"

func SuccessResponse(c *gin.Context, data interface{}) {
    c.JSON(200, gin.H{"success": true, "data": data})
}

func ErrorResponse(c *gin.Context, code int, message string) {
    c.JSON(code, gin.H{"success": false, "message": message})
}
```

---

## 8ï¸âƒ£ ä¼˜åŒ–ç”¨æˆ·å¤„ç†é€»è¾‘

### `handlers/user.go`

```go
package handlers

import (
    "net/http"
    "your_project_name/models"
    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
)

var db *gorm.DB

func SetDB(database *gorm.DB) {
    db = database
}

func GetUsers(c *gin.Context) {
    var users []models.User
    db.Find(&users)
    utils.SuccessResponse(c, users)
}

func DeleteUser(c *gin.Context) {
    id := c.Param("id")
    db.Delete(&models.User{}, id)
    utils.SuccessResponse(c, gin.H{"message": "åˆ é™¤æˆåŠŸ"})
}

func RestoreUser(c *gin.Context) {
    id := c.Param("id")
    db.Unscoped().Model(&models.User{}).Where("id = ?", id).Update("deleted_at", nil)
    utils.SuccessResponse(c, gin.H{"message": "æ¢å¤æˆåŠŸ"})
}
```

---

## 9ï¸âƒ£ å¯åŠ¨ä¸»ç¨‹åº `main.go`

```go
package main

import (
    "your_project_name/config"
    "your_project_name/handlers"
    "your_project_name/middlewares"
    "your_project_name/models"
    "github.com/gin-gonic/gin"
)

func main() {
    db := config.ConnectDB()
    models.RegisterHooks(db)

    handlers.SetDB(db)

    r := gin.Default()

    api := r.Group("/api")
    {
        api.POST("/login", handlers.Login)

        // å—ä¿æŠ¤çš„è·¯ç”±
        protected := api.Group("")
        protected.Use(middlewares.AuthMiddleware)
        {
            protected.GET("/users", handlers.GetUsers)

            admin := protected.Group("")
            admin.Use(middlewares.AdminOnly)
            {
                admin.DELETE("/users/:id", handlers.DeleteUser)
                admin.PUT("/restore/users/:id", handlers.RestoreUser)
            }
        }
    }

    r.Run(":8080")
}
```

---

## âœ… è¯·æ±‚ç¤ºä¾‹

### ç™»å½•è·å– Token

```bash
POST /api/login
{
  "username": "alice",
  "password": "123456"
}
```

è¿”å›ï¼š

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6..."
}
```

### è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆæ‰€æœ‰è§’è‰²éƒ½å¯è®¿é—®ï¼‰

```bash
GET /api/users
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

### åˆ é™¤ç”¨æˆ·ï¼ˆä»…é™ç®¡ç†å‘˜ï¼‰

```bash
DELETE /api/users/1
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...
```

---

## ğŸ¯ æ€»ç»“

| åŠŸèƒ½         | æè¿°                                 |
| ------------ | ------------------------------------ |
| æ•°æ®åº“       | æ”¹ä¸ºä½¿ç”¨ MySQL                       |
| ç™»å½•è®¤è¯     | ä½¿ç”¨ JWT å®ç°                        |
| æƒé™æ§åˆ¶     | ä½¿ç”¨ Gin ä¸­é—´ä»¶é™åˆ¶åªæœ‰ admin å¯åˆ é™¤ |
| å“åº”ç»Ÿä¸€å°è£… | ä½¿ç”¨ `utils.Response` è¿”å›ç»Ÿä¸€æ ¼å¼   |
| ç»“æ„æ¸…æ™°     | æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•           |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

- ğŸ§ª æ·»åŠ å•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨ Testify + GORM æµ‹è¯•æ¨¡å¼ï¼‰
- ğŸ“„ åŠ å…¥ Swagger æ¥å£æ–‡æ¡£æ”¯æŒ
- ğŸ“¦ ä½¿ç”¨ Redis ç¼“å­˜ Token é»‘åå•
- ğŸ§­ æ„å»ºå®Œæ•´çš„ RBAC ç³»ç»Ÿï¼ˆè§’è‰²-æƒé™å…³è”ï¼‰

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­å¸®ä½ æ·»åŠ è¿™äº›é«˜çº§æ¨¡å—ï¼Œæ¬¢è¿éšæ—¶å‘Šè¯‰æˆ‘ ğŸ‘‡

â€

# å®ç°[æµ‹è¯•ã€ç¼“å­˜ã€RBAC]

- ğŸ§ª æ·»åŠ å•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨ Testify + GORM æµ‹è¯•æ¨¡å¼ï¼‰
- ğŸ“¦ ä½¿ç”¨ Redis ç¼“å­˜ Token é»‘åå•
- ğŸ§­ æ„å»ºå®Œæ•´çš„ RBAC ç³»ç»Ÿï¼ˆè§’è‰²-æƒé™å…³è”ï¼‰

éå¸¸æ£’ï¼ä½ å·²ç»æ‰“ä¸‹äº†åšå®çš„åŸºç¡€ï¼Œç°åœ¨æˆ‘ä»¬ç»§ç»­ä¸ºè¿™ä¸ªé¡¹ç›®æ·»åŠ  **å•å…ƒæµ‹è¯•ã€Redis ç¼“å­˜ Token é»‘åå•** å’Œ **å®Œæ•´çš„ RBAC æƒé™ç³»ç»Ÿï¼ˆè§’è‰²-æƒé™å…³è”ï¼‰** ã€‚æˆ‘ä»¬å°†ä¾æ¬¡è®²è§£æ¯ä¸ªæ¨¡å—ï¼Œå¹¶æä¾›å®Œæ•´çš„ç¤ºä¾‹ä»£ç ã€‚

---

## âœ… ç¬¬ä¸€éƒ¨åˆ†ï¼šæ·»åŠ å•å…ƒæµ‹è¯•ï¼ˆä½¿ç”¨ Testify + GORM æµ‹è¯•æ¨¡å¼ï¼‰

æˆ‘ä»¬å°†ä½¿ç”¨ä»¥ä¸‹å·¥å…·ï¼š

- â€‹`testing` æ ‡å‡†åº“
- â€‹`testify`â€‹ çš„ `require/assert` åšæ–­è¨€
- GORM çš„å†…å­˜æ•°æ®åº“ï¼ˆSQLite å†…å­˜æ¨¡å¼ï¼‰åšéš”ç¦»æµ‹è¯•

---

### 1. å®‰è£…ä¾èµ–

```bash
go get github.com/stretchr/testify
```

---

### 2. ç¤ºä¾‹æµ‹è¯•æ–‡ä»¶ `handlers/user_test.go`

```go
package handlers

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func setupTestDB() *gorm.DB {
    db, err := gorm.Open(sqlite.Open("file::memory:?cache=shared"), &gorm.Config{})
    if err != nil {
        panic("failed to connect database")
    }
    db.AutoMigrate(&models.User{})
    return db
}

func TestGetUsers(t *testing.T) {
    gin.SetMode(gin.TestMode)
    r := gin.Default()

    // åˆå§‹åŒ–æµ‹è¯• DB
    testDB := setupTestDB()
    SetDB(testDB)

    // æ’å…¥æµ‹è¯•æ•°æ®
    testDB.Create(&models.User{Username: "alice", Password: "123456", Role: models.RoleUser})
    testDB.Create(&models.User{Username: "bob", Password: "abcdef", Role: models.RoleAdmin})

    r.GET("/api/users", GetUsers)

    req, _ := http.NewRequest(http.MethodGet, "/api/users", nil)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)

    var resp map[string]interface{}
    _ = json.Unmarshal(w.Body.Bytes(), &resp)

    data := resp["data"].([]interface{})
    assert.Len(t, data, 2)
}
```

---

### 3. ç¤ºä¾‹ç™»å½•æµ‹è¯• `handlers/auth_test.go`

```go
func TestLoginSuccess(t *testing.T) {
    gin.SetMode(gin.TestMode)
    r := gin.Default()

    testDB := setupTestDB()
    SetDB(testDB)

    hashedPassword, _ := bcrypt.GenerateFromPassword([]byte("123456"), bcrypt.DefaultCost)
    testDB.Create(&models.User{
        Username: "alice",
        Password: string(hashedPassword),
        Role:     models.RoleUser,
    })

    r.POST("/api/login", Login)

    body := bytes.NewBufferString(`{"username":"alice","password":"123456"}`)
    req, _ := http.NewRequest(http.MethodPost, "/api/login", body)
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)
    assert.Contains(t, w.Body.String(), "token")
}
```

---

## âœ… ç¬¬äºŒéƒ¨åˆ†ï¼šä½¿ç”¨ Redis ç¼“å­˜ Token é»‘åå•

å½“ç”¨æˆ·æ³¨é”€æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°† Token åŠ å…¥é»‘åå•ï¼Œé˜²æ­¢å…¶ç»§ç»­è¢«ä½¿ç”¨ã€‚

---

### 1. å®‰è£… Redis åŒ…

```bash
go get github.com/go-redis/redis/v8
```

---

### 2. åˆ›å»º Redis å·¥å…·åŒ… `utils/redis.go`

```go
package utils

import (
    "context"
    "time"

    "github.com/go-redis/redis/v8"
)

var RedisClient *redis.Client

func InitRedis() {
    RedisClient = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "",
        DB:       0,
    })
}

func AddToBlacklist(token string, exp time.Duration) error {
    ctx := context.Background()
    return RedisClient.Set(ctx, "blacklist:"+token, "1", exp).Err()
}

func IsTokenBlacklisted(token string) bool {
    ctx := context.Background()
    val, _ := RedisClient.Get(ctx, "blacklist:"+token).Result()
    return val == "1"
}
```

---

### 3. ä¿®æ”¹ JWT ç™»å‡ºæ¥å£ `handlers/auth.go`

```go
// æ–°å¢ç™»å‡ºæ¥å£
func Logout(c *gin.Context) {
    authHeader := c.GetHeader("Authorization")
    tokenString := strings.TrimPrefix(authHeader, "Bearer ")

    _, err := jwt.ParseWithClaims(tokenString, &services.Claims{}, func(token *jwt.Token) (interface{}, error) {
        return services.JwtKey, nil
    })

    if err == nil {
        utils.AddToBlacklist(tokenString, 24*time.Hour)
        utils.SuccessResponse(c, gin.H{"message": "å·²ç™»å‡º"})
        return
    }

    utils.ErrorResponse(c, http.StatusUnauthorized, "æ— æ•ˆçš„ token")
}
```

---

### 4. ä¿®æ”¹ä¸­é—´ä»¶æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­ `middlewares/auth.go`

```go
if utils.IsTokenBlacklisted(tokenString) {
    c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "token å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•"})
    return
}
```

---

## âœ… ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ„å»ºå®Œæ•´çš„ RBAC ç³»ç»Ÿï¼ˆè§’è‰²-æƒé™å…³è”ï¼‰

æˆ‘ä»¬å°†å®ç°ï¼š

- è§’è‰²è¡¨ (`roles`)
- æƒé™è¡¨ (`permissions`)
- è§’è‰²-æƒé™å…³è”è¡¨ (`role_permissions`)
- ç”¨æˆ·-è§’è‰²è¡¨ (`user_roles`)
- æ¥å£æ§åˆ¶åŸºäºæƒé™åï¼ˆå¦‚ `can_delete_user`â€‹, `can_edit_content`ï¼‰

---

### 1. æ•°æ®æ¨¡å‹å®šä¹‰

#### `models/role.go`

```go
type Role struct {
    ID          uint           `json:"id" gorm:"primaryKey"`
    Name        string         `json:"name" gorm:"unique"`
    Permissions []Permission   `json:"permissions" gorm:"many2many:role_permissions;"`
    DeletedAt   gorm.DeletedAt `json:"-"`
}
```

#### `models/permission.go`

```go
type Permission struct {
    ID   uint   `json:"id" gorm:"primaryKey"`
    Name string `json:"name" gorm:"unique"` // å¦‚ can_delete_user, can_edit_post
}
```

---

### 2. è‡ªåŠ¨è¿ç§»ä¸åˆå§‹åŒ–æƒé™

#### `main.go`

```go
db.AutoMigrate(&models.User{}, &models.Role{}, &models.Permission{})

// åˆå§‹åŒ–é»˜è®¤æƒé™
db.FirstOrCreate(&models.Permission{Name: "can_delete_user"}, models.Permission{Name: "can_delete_user"})
db.FirstOrCreate(&models.Permission{Name: "can_edit_post"}, models.Permission{Name: "can_edit_post"})

// åˆå§‹åŒ–è§’è‰²
var adminRole models.Role
db.Where("name = ?", "admin").FirstOrCreate(&adminRole, models.Role{Name: "admin"})
db.Model(&adminRole).Association("Permissions").Append([]models.Permission{
    {Name: "can_delete_user"},
    {Name: "can_edit_post"},
})
```

---

### 3. ä¸­é—´ä»¶ï¼šæƒé™æ ¡éªŒ

#### `middlewares/permission.go`

```go
func HasPermission(permissionName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        username, _ := c.Get("username")
        var user models.User
        db.Where("username = ?", username).Preload("Roles.Permissions").First(&user)

        for _, role := range user.Roles {
            for _, perm := range role.Permissions {
                if perm.Name == permissionName {
                    c.Next()
                    return
                }
            }
        }

        c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™æ“ä½œ"})
    }
}
```

---

### 4. æ§åˆ¶å™¨ä¸­ä½¿ç”¨æƒé™æ§åˆ¶

#### `handlers/user.go`

```go
protected.POST("/delete/:id", middlewares.HasPermission("can_delete_user"), handlers.DeleteUser)
```

---

## ğŸ¯ æ€»ç»“åŠŸèƒ½æ‰©å±•

| æ¨¡å—               | åŠŸèƒ½æè¿°                                     |
| ------------------ | -------------------------------------------- |
| å•å…ƒæµ‹è¯•           | ä½¿ç”¨ testify + SQLite in-memory è¿›è¡Œéš”ç¦»æµ‹è¯• |
| Redis Token é»‘åå• | ç™»å‡ºå Token ä¸å†å¯ç”¨                        |
| RBAC ç³»ç»Ÿ          | æ”¯æŒè§’è‰²-æƒé™å¤šå¯¹å¤šï¼Œç»†ç²’åº¦æƒé™æ§åˆ¶          |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

- ğŸ“„ æ·»åŠ  Swagger æ–‡æ¡£æ”¯æŒï¼Œä½¿ç”¨ `swaggo/swag`
- ğŸ§ª æ·»åŠ é›†æˆæµ‹è¯•ï¼Œæµ‹è¯•æ•´ä¸ª API é“¾è·¯
- ğŸ” å¼•å…¥ HTTPS + TLS é…ç½®
- ğŸ“¦ æ„å»º Docker å®¹å™¨éƒ¨ç½²
- ğŸ“Š æ·»åŠ  Prometheus ç›‘æ§æŒ‡æ ‡

---

å¦‚æœä½ å¸Œæœ›æˆ‘å¸®ä½ å®ç°å…¶ä¸­ä»»æ„ä¸€ä¸ªæ¨¡å—ï¼ˆæ¯”å¦‚ Swagger æ¥å£æ–‡æ¡£ï¼‰ï¼Œæ¬¢è¿éšæ—¶å‘Šè¯‰æˆ‘ ğŸ‘‡ æˆ‘ä¼šç»§ç»­ä¸ºä½ æ‰©å±•å®Œæ•´ä»£ç å’Œé…ç½®è¯´æ˜ã€‚

---

## ğŸ” ä»£ç è§£æï¼š

```go
db.Where("username = ?", username).Preload("Roles.Permissions").First(&user)
```

### åˆ†è§£è¯´æ˜ï¼š

| éƒ¨åˆ†                                | å«ä¹‰                                                                                            |
| ----------------------------------- | ----------------------------------------------------------------------------------------------- |
| â€‹`db`                               | GORM çš„æ•°æ®åº“è¿æ¥å¯¹è±¡ï¼Œä»£è¡¨å½“å‰ä¸æ•°æ®åº“çš„ä¼šè¯ã€‚                                                 |
| â€‹`.Where("username = ?", username)` | æ·»åŠ æŸ¥è¯¢æ¡ä»¶ï¼ŒæŸ¥æ‰¾ç”¨æˆ·åç­‰äºä¼ å…¥çš„ `username` çš„ç”¨æˆ·è®°å½•ã€‚                                      |
| â€‹`.Preload("Roles.Permissions")`    | **é¢„åŠ è½½**ç”¨æˆ·æ‹¥æœ‰çš„è§’è‰²ä»¥åŠè¿™äº›è§’è‰²æ‰€æ‹¥æœ‰çš„æƒé™ã€‚è¿™ä¸€æ­¥æ˜¯ä¸ºäº†é¿å…åç»­è®¿é—®æ—¶å‘ç”Ÿ N+1 æŸ¥è¯¢é—®é¢˜ã€‚ |
| â€‹`.First(&user)`                    | æŸ¥æ‰¾ç¬¬ä¸€æ¡åŒ¹é…ç»“æœå¹¶èµ‹å€¼ç»™å˜é‡ `user`ã€‚                                                         |

---

## ğŸ§± å‡è®¾æ¨¡å‹ç»“æ„å¦‚ä¸‹ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š

```go
type User struct {
    ID       uint   `gorm:"primaryKey"`
    Username string `gorm:"unique"`
    Password string
    Roles    []Role `gorm:"many2many:user_roles;"`
}

type Role struct {
    ID          uint         `gorm:"primaryKey"`
    Name        string       `gorm:"unique"`
    Permissions []Permission `gorm:"many2many:role_permissions;"`
}

type Permission struct {
    ID   uint   `gorm:"primaryKey"`
    Name string `gorm:"unique"` // å¦‚ "can_delete_user", "can_edit_post"
}
```

---

## ğŸ’¡ ä¸¾ä¾‹è¯´æ˜ï¼š

å‡è®¾æ•°æ®åº“ä¸­æœ‰ä»¥ä¸‹æ•°æ®ï¼š

### ç”¨æˆ·è¡¨ (`users`)

| id  | username |
| --- | -------- |
| 1   | alice    |

### è§’è‰²è¡¨ (`roles`)

| id  | name  |
| --- | ----- |
| 1   | admin |

### æƒé™è¡¨ (`permissions`)

| id  | name             |
| --- | ---------------- |
| 1   | can_delete_user  |
| 2   | can_edit_content |

### è§’è‰²-æƒé™å…³è”è¡¨ (`role_permissions`)

| role_id | permission_id |
| ------- | ------------- |
| 1       | 1             |
| 1       | 2             |

### ç”¨æˆ·-è§’è‰²å…³è”è¡¨ (`user_roles`)

| user_id | role_id |
| ------- | ------- |
| 1       | 1       |

---

## âœ… æ‰§è¡Œæ•ˆæœï¼š

å½“æ‰§è¡Œï¼š

```go
var user User
db.Where("username = ?", "alice").Preload("Roles.Permissions").First(&user)
```

- GORM ä¼šï¼š

  1. å…ˆæŸ¥å‡º `alice` è¿™ä¸ªç”¨æˆ·ï¼›
  2. ç„¶åæ ¹æ®å…¶å…³è”çš„ `Roles`â€‹ è¡¨ï¼ˆå³ `admin` è§’è‰²ï¼‰ï¼›
  3. å†æŸ¥å‡ºè¯¥è§’è‰²çš„æ‰€æœ‰ `Permissions`â€‹ï¼ˆå³ `can_delete_user`â€‹, `can_edit_content`ï¼‰ï¼›

æœ€ç»ˆï¼Œä½ å¯ä»¥åœ¨ä»£ç ä¸­ç›´æ¥è®¿é—®ç”¨æˆ·çš„æƒé™ï¼š

```go
for _, role := range user.Roles {
    for _, perm := range role.Permissions {
        fmt.Println(perm.Name) // è¾“å‡ºï¼šcan_delete_user, can_edit_content
    }
}
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹ï¼š

- å¦‚æœæ²¡æœ‰ `.Preload("Roles.Permissions")`â€‹ï¼Œåœ¨è®¿é—® `user.Roles`â€‹ æˆ– `user.Roles.Permissions` æ—¶ä¼šå‘ç”Ÿæ‡’åŠ è½½ï¼ˆLazy Loadingï¼‰ï¼Œå¯¼è‡´é¢å¤–çš„ SQL æŸ¥è¯¢ï¼Œå½±å“æ€§èƒ½ã€‚
- ä½¿ç”¨ `.Preload()` å¯ä»¥ä¸€æ¬¡æ€§å°†æ‰€éœ€çš„æ•°æ®å…¨éƒ¨åŠ è½½è¿›æ¥ï¼Œæé«˜æ•ˆç‡ï¼Œé€‚ç”¨äº RBACã€èœå•æ ‘ç­‰åµŒå¥—ç»“æ„åœºæ™¯ã€‚

---

## ğŸ›  ä½¿ç”¨åœºæ™¯ç¤ºä¾‹ï¼ˆç»“åˆä¸­é—´ä»¶åšæƒé™åˆ¤æ–­ï¼‰

```go
func HasPermission(permissionName string) gin.HandlerFunc {
    return func(c *gin.Context) {
        username, _ := c.Get("username")
        var user User
        db.Where("username = ?", username).
            Preload("Roles.Permissions").
            First(&user)

        hasPerm := false
        for _, role := range user.Roles {
            for _, perm := range role.Permissions {
                if perm.Name == permissionName {
                    hasPerm = true
                    break
                }
            }
        }

        if !hasPerm {
            c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™æ“ä½œ"})
            return
        }

        c.Next()
    }
}
```

ç„¶åä½ å¯ä»¥è¿™æ ·ä½¿ç”¨å®ƒï¼š

```go
protected.DELETE("/users/:id", middlewares.HasPermission("can_delete_user"), handlers.DeleteUser)
```

---

## ğŸ“Œ æ€»ç»“ï¼š

| å†…å®¹                             | è¯´æ˜                                |
| -------------------------------- | ----------------------------------- |
| â€‹`.Where(...)`                   | æŸ¥è¯¢æŒ‡å®šç”¨æˆ·åçš„ç”¨æˆ·                |
| â€‹`.Preload("Roles.Permissions")` | ä¸€æ¬¡æ€§åŠ è½½è§’è‰²å’Œæƒé™ï¼Œé¿å… N+1 æŸ¥è¯¢ |
| â€‹`.First(&user)`                 | è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„ç”¨æˆ·è®°å½•            |
| ç”¨é€”                             | å®ç° RBAC æƒé™éªŒè¯ä¸­çš„æƒé™æ ¡éªŒé€»è¾‘  |

å¦‚æœä½ è¿˜æƒ³äº†è§£å¦‚ä½•ç”¨ Swagger è‡ªåŠ¨ç”Ÿæˆæ¥å£æ–‡æ¡£ã€æˆ–è€…ç”¨ Redis ç¼“å­˜æƒé™ä¿¡æ¯æå‡æ€§èƒ½ï¼Œæˆ‘ä¹Ÿå¯ä»¥ç»§ç»­ä¸ºä½ è®²è§£ ğŸ‘‡

---

# ç¼“å­˜æƒé™ä¿¡æ¯,å¯ä»¥åšäº›ä»€ä¹ˆï¼Ÿé…åˆ RBAC

åœ¨ **RBACï¼ˆåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼‰** ç³»ç»Ÿä¸­ï¼Œç¼“å­˜æƒé™ä¿¡æ¯å¯ä»¥æ˜¾è‘—æå‡æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚ç‰¹åˆ«æ˜¯åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œé¢‘ç¹åœ°ä»æ•°æ®åº“æŸ¥è¯¢ç”¨æˆ·çš„æƒé™å¯èƒ½ä¼šå¯¼è‡´å»¶è¿Ÿã€èµ„æºæµªè´¹ç”šè‡³æˆä¸ºç“¶é¢ˆã€‚

---

## ğŸ§  ç¼“å­˜æƒé™ä¿¡æ¯å¯ä»¥åšä»€ä¹ˆï¼Ÿ

å°†ç”¨æˆ·æˆ–è§’è‰²çš„æƒé™ä¿¡æ¯ç¼“å­˜åˆ°å†…å­˜æˆ– Redis ä¸­ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä½œç”¨ï¼š

| åŠŸèƒ½/ä¼˜åŠ¿               | è¯´æ˜                                               |
| ----------------------- | -------------------------------------------------- |
| âŒ å‡å°‘æ•°æ®åº“æŸ¥è¯¢       | ç”¨æˆ·æ¯æ¬¡è¯·æ±‚æ—¶ä¸å†éœ€è¦æŸ¥ DB è·å–æƒé™ï¼Œæé«˜å“åº”é€Ÿåº¦ |
| âš¡ æå‡æ€§èƒ½             | å°¤å…¶é€‚ç”¨äºé«˜é¢‘æ¥å£è°ƒç”¨ã€æƒé™æ ¡éªŒå¯†é›†çš„ç³»ç»Ÿ         |
| ğŸ” å®ç°å¿«é€Ÿæƒé™åˆ·æ–°æœºåˆ¶ | å½“æƒé™å˜æ›´æ—¶ä¸»åŠ¨æ›´æ–°ç¼“å­˜ï¼Œè€Œä¸æ˜¯ç­‰å¾…è¿‡æœŸ           |
| ğŸ”„ æ”¯æŒ RBAC æƒé™çƒ­æ›´æ–° | ä¿®æ”¹æƒé™åæ— éœ€é‡å¯æœåŠ¡å³å¯ç”Ÿæ•ˆ                     |
| ğŸ§± é™ä½æ•°æ®åº“å‹åŠ›       | å‡è½»æ•°æ®åº“è´Ÿæ‹…ï¼Œæé«˜æ•´ä½“ç³»ç»Ÿç¨³å®šæ€§                 |

---

## ğŸ’¡ ä½¿ç”¨åœºæ™¯ä¸¾ä¾‹

- âœ… ç”¨æˆ·ç™»å½•åï¼Œå°†å…¶æ‰€æœ‰æƒé™ç¼“å­˜åˆ° Redis æˆ–å†…å­˜ä¸­ï¼›
- ğŸ” æ¯æ¬¡æ¥å£è¯·æ±‚æ—¶ï¼Œç›´æ¥ä»ç¼“å­˜è·å–æƒé™è¿›è¡Œæ ¡éªŒï¼›
- ğŸ”„ ç®¡ç†å‘˜ä¿®æ”¹æŸä¸ªè§’è‰²çš„æƒé™åï¼Œè‡ªåŠ¨æ¸…ç†è¯¥è§’è‰²çš„ç¼“å­˜ï¼›
- ğŸ•’ è®¾ç½®åˆç†çš„ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆå¦‚ 5 åˆ†é’Ÿï¼‰ï¼Œé˜²æ­¢æ•°æ®é™ˆæ—§ã€‚

---

## ğŸ› ï¸ å¦‚ä½•å®ç°ï¼šé…åˆ RBAC ç³»ç»Ÿç¼“å­˜æƒé™

æˆ‘ä»¬ä»¥ä½¿ç”¨ **Redis** ç¼“å­˜ä¸ºä¾‹ï¼Œä»‹ç»å¦‚ä½•å®ç°ä¸€ä¸ªé«˜æ•ˆçš„æƒé™ç¼“å­˜ç³»ç»Ÿã€‚

---

### 1. å®‰è£…ä¾èµ–

```bash
go get github.com/go-redis/redis/v8
```

---

### 2. åˆå§‹åŒ– Redis å®¢æˆ·ç«¯ï¼ˆ`utils/redis.go`ï¼‰

```go
package utils

import (
    "context"
    "github.com/go-redis/redis/v8"
)

var RedisClient *redis.Client
var Ctx = context.Background()

func InitRedis() {
    RedisClient = redis.NewClient(&redis.Options{
        Addr:     "localhost:6379", // Redis åœ°å€
        Password: "",               // å¯†ç ï¼ˆæ— åˆ™ç•™ç©ºï¼‰
        DB:       0,                // é»˜è®¤æ•°æ®åº“
    })
}
```

---

### 3. ç¼“å­˜ç”¨æˆ·æƒé™é€»è¾‘ï¼ˆ`services/permission_cache.go`ï¼‰

```go
package services

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "your_project_name/models"
    "your_project_name/utils"
)

// ç¼“å­˜ Key æ ¼å¼ï¼špermissions:<username>
const permissionCacheKey = "permissions:%s"

// ç¼“å­˜æƒé™åˆ° Redis
func CacheUserPermissions(username string, perms []string) error {
    key := fmt.Sprintf(permissionCacheKey, username)
    data, _ := json.Marshal(perms)
    return utils.RedisClient.Set(utils.Ctx, key, data, 5*time.Minute).Err()
}

// ä» Redis è·å–æƒé™
func GetUserPermissionsFromCache(username string) ([]string, bool) {
    key := fmt.Sprintf(permissionCacheKey, username)
    val, err := utils.RedisClient.Get(utils.Ctx, key).Result()
    if err != nil {
        return nil, false
    }

    var perms []string
    _ = json.Unmarshal([]byte(val), &perms)
    return perms, true
}

// æ¸…é™¤ç”¨æˆ·çš„æƒé™ç¼“å­˜
func ClearUserPermissionCache(username string) {
    key := fmt.Sprintf(permissionCacheKey, username)
    utils.RedisClient.Del(utils.Ctx, key)
}
```

---

### 4. ç™»å½•æ—¶ç¼“å­˜æƒé™ï¼ˆ`handlers/auth.go`ï¼‰

```go
// ç”¨æˆ·ç™»å½•æˆåŠŸåï¼Œç¼“å­˜æƒé™
var user models.User
db.Where("username = ?", input.Username).
    Preload("Roles.Permissions").
    First(&user)

// æå–æƒé™ååˆ—è¡¨
var permissions []string
for _, role := range user.Roles {
    for _, perm := range role.Permissions {
        permissions = append(permissions, perm.Name)
    }
}

// ç¼“å­˜æƒé™
services.CacheUserPermissions(user.Username, permissions)
```

---

### 5. ä¸­é—´ä»¶è¯»å–ç¼“å­˜æƒé™ï¼ˆ`middlewares/permission.go`ï¼‰

```go
func HasPermission(requiredPerm string) gin.HandlerFunc {
    return func(c *gin.Context) {
        username, _ := c.Get("username")
        perms, ok := services.GetUserPermissionsFromCache(username.(string))

        if !ok {
            c.AbortWithStatusJSON(401, gin.H{"error": "æƒé™ç¼“å­˜æœªå‘½ä¸­ï¼Œè¯·é‡æ–°ç™»å½•"})
            return
        }

        hasPerm := false
        for _, p := range perms {
            if p == requiredPerm {
                hasPerm = true
                break
            }
        }

        if !hasPerm {
            c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™æ“ä½œ"})
            return
        }

        c.Next()
    }
}
```

---

### 6. è§’è‰²æƒé™å˜æ›´æ—¶æ¸…é™¤ç¼“å­˜ï¼ˆ`handlers/role.go`ï¼‰

```go
func UpdateRolePermissions(c *gin.Context) {
    roleName := c.Param("name")

    // ... æ›´æ–°è§’è‰²æƒé™é€»è¾‘ ...

    // å‡è®¾æˆ‘ä»¬çŸ¥é“å“ªäº›ç”¨æˆ·å±äºè¿™ä¸ªè§’è‰²ï¼Œæ‰¹é‡æ¸…é™¤ä»–ä»¬çš„æƒé™ç¼“å­˜
    var users []models.User
    db.Where("role = ?", roleName).Find(&users)
    for _, user := range users {
        services.ClearUserPermissionCache(user.Username)
    }

    c.JSON(200, gin.H{"message": "æƒé™å·²æ›´æ–°ï¼Œç¼“å­˜å·²æ¸…é™¤"})
}
```

---

## ğŸ¯ æ€»ç»“ï¼šç¼“å­˜æƒé™ + RBAC çš„ä¼˜åŠ¿

| ä¼˜ç‚¹      | æè¿°                                                    |
| --------- | ------------------------------------------------------- |
| âœ… é«˜æ€§èƒ½ | ä¸å†æ¯æ¬¡éƒ½å»æ•°æ®åº“æŸ¥è¯¢æƒé™                              |
| âœ… å¯æ§æ€§ | å¯è®¾å®šç¼“å­˜æ—¶é—´ã€ä¸»åŠ¨åˆ·æ–°                                |
| âœ… é«˜å¯ç”¨ | å³ä½¿æ•°æ®åº“æš‚æ—¶ä¸å¯ç”¨ï¼Œä»å¯ç»§ç»­éªŒè¯ç¼“å­˜ä¸­çš„æƒé™          |
| âœ… æ˜“æ‰©å±• | åç»­å¯æ¥å…¥åˆ†å¸ƒå¼ç¼“å­˜ï¼ˆå¦‚ Redis é›†ç¾¤ï¼‰ã€æ”¯æŒæ›´å¤šæƒé™ç»´åº¦ |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

ä½ å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–æƒé™ç¼“å­˜ç³»ç»Ÿï¼š

| åŠŸèƒ½                              | è¯´æ˜                                          |
| --------------------------------- | --------------------------------------------- |
| ğŸ§ª ç¼–å†™å•å…ƒæµ‹è¯•éªŒè¯ç¼“å­˜æ˜¯å¦ç”Ÿæ•ˆ   | ä½¿ç”¨ `testify` æµ‹è¯•ç¼“å­˜å‘½ä¸­ä¸å¤±æ•ˆ             |
| ğŸ§© æ·»åŠ æƒé™æ ‡ç­¾æ ‘ç»“æ„             | æ”¯æŒæŒ‰æ¨¡å—ï¼ˆå¦‚ user: _ã€post:_ ï¼‰åšé€šé…ç¬¦åŒ¹é… |
| ğŸ“Š æ¥å…¥ Prometheus ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡ | ç»Ÿè®¡ hit / miss æ¬¡æ•°                          |
| ğŸ“¦ æ”¯æŒå¤šçº§ç¼“å­˜ï¼ˆå†…å­˜ + Redisï¼‰   | æœ¬åœ° LRU + Redis ä¸¤çº§ç¼“å­˜æ¶æ„                 |
| ğŸ“ˆ ç”¨å¸ƒéš†è¿‡æ»¤å™¨å‡å°‘æ— æ•ˆæŸ¥è¯¢       | é˜²æ­¢å¤§é‡ä¸å­˜åœ¨ç”¨æˆ·çš„æ— æ•ˆç¼“å­˜æŸ¥è¯¢              |

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­ä¸ºä½ æ·»åŠ è¿™äº›é«˜çº§åŠŸèƒ½ï¼ˆæ¯”å¦‚ï¼šå¤šçº§ç¼“å­˜ã€é€šé…ç¬¦æƒé™åŒ¹é…ã€Prometheus ç›‘æ§ç­‰ï¼‰ï¼Œæ¬¢è¿éšæ—¶å‘Šè¯‰æˆ‘ ğŸ‘‡ æˆ‘ä¼šç»§ç»­ä¸ºä½ ç¼–å†™å®Œæ•´ä»£ç å’Œé…ç½®ï¼

â€

| ğŸ“¦ æ”¯æŒå¤šçº§ç¼“å­˜ï¼ˆå†…å­˜ + Redisï¼‰ | æœ¬åœ° LRU + Redis ä¸¤çº§ç¼“å­˜æ¶æ„    |
| ------------------------------- | -------------------------------- |
| ğŸ“ˆ ç”¨å¸ƒéš†è¿‡æ»¤å™¨å‡å°‘æ— æ•ˆæŸ¥è¯¢     | é˜²æ­¢å¤§é‡ä¸å­˜åœ¨ç”¨æˆ·çš„æ— æ•ˆç¼“å­˜æŸ¥è¯¢ |

éå¸¸å¥½ï¼æˆ‘ä»¬æ¥ä¸€èµ·å®ç° **å¤šçº§ç¼“å­˜æ¶æ„ï¼ˆå†…å­˜ LRU + Redisï¼‰** å’Œ **ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å‡å°‘æ— æ•ˆæŸ¥è¯¢**ã€‚è¿™æ˜¯ç°ä»£é«˜æ€§èƒ½æƒé™ç³»ç»Ÿä¸­å¸¸è§çš„åšæ³•ï¼Œæ—¢èƒ½ä¿è¯è®¿é—®é€Ÿåº¦ï¼Œåˆèƒ½é™ä½åç«¯å‹åŠ›ã€‚

---

# ğŸ§© ä¸€ã€æ”¯æŒå¤šçº§ç¼“å­˜ï¼šå†…å­˜ LRU + Redis

## ğŸ¯ ç›®æ ‡ï¼š

- ä½¿ç”¨æœ¬åœ°å†…å­˜ç¼“å­˜ï¼ˆLRUï¼‰åšä¸€çº§ç¼“å­˜ï¼Œæå‡è®¿é—®é€Ÿåº¦ï¼›
- ä½¿ç”¨ Redis åšäºŒçº§ç¼“å­˜ï¼Œé˜²æ­¢æœåŠ¡é‡å¯æ•°æ®ä¸¢å¤±ï¼›
- æŸ¥è¯¢æ—¶ä¼˜å…ˆæŸ¥å†…å­˜ â†’ æŸ¥ Redis â†’ å›é€€æ•°æ®åº“ï¼›
- æ›´æ–°æ—¶åŒæ­¥æ¸…ç†æœ¬åœ°ç¼“å­˜å¹¶æ›´æ–° Redisã€‚

---

## ğŸ“¦ å®‰è£…ä¾èµ–ï¼š

```bash
go get github.com/hashicorp/golang-lru/v2
```

---

## ğŸ”§ ç¼“å­˜ç»“æ„è®¾è®¡

æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ª `PermissionCache` ç»“æ„ä½“ï¼Œå°è£…ä»¥ä¸‹é€»è¾‘ï¼š

| å±‚çº§     | ç±»å‹         | ç‰¹ç‚¹               |
| -------- | ------------ | ------------------ |
| ä¸€çº§ç¼“å­˜ | LRU å†…å­˜ç¼“å­˜ | å¿«é€Ÿå“åº”ã€ä½å»¶è¿Ÿ   |
| äºŒçº§ç¼“å­˜ | Redis        | æŒä¹…åŒ–ã€åˆ†å¸ƒå¼å…±äº« |
| æœ€ç»ˆå›é€€ | æ•°æ®åº“       | ç¡®ä¿æœ€ç»ˆä¸€è‡´æ€§     |

---

## ğŸ“ æ–‡ä»¶ç»“æ„ï¼ˆæ–°å¢ï¼‰

```
utils/
â”œâ”€â”€ redis.go
â”œâ”€â”€ lru_cache.go
services/
â””â”€â”€ permission_cache.go
```

---

## ğŸ“„ 1. å®ç° LRU æœ¬åœ°ç¼“å­˜ï¼ˆ`utils/lru_cache.go`ï¼‰

```go
package utils

import (
    "sync"
    "github.com/hashicorp/golang-lru/v2"
)

const LocalCacheSize = 1024 // å¯è°ƒæ•´å¤§å°

var (
    localCache *lru.Cache[string, []string]
    mu         sync.RWMutex
)

func InitLocalCache() {
    var err error
    localCache, err = lru.NewWithEvict[string, []string](LocalCacheSize, func(key string, value []string) {
        // å¯é€‰çš„æ·˜æ±°å›è°ƒï¼ˆå¦‚å†™å…¥æ—¥å¿—æˆ–åå°æŒä¹…åŒ–ï¼‰
    })
    if err != nil {
        panic("æ— æ³•åˆå§‹åŒ–æœ¬åœ° LRU ç¼“å­˜")
    }
}
```

---

## ğŸ“„ 2. å¤šçº§ç¼“å­˜å°è£…ï¼ˆ`services/permission_cache.go`ï¼‰

```go
package services

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "your_project_name/utils"
)

// Redis Key æ ¼å¼
const permissionRedisKey = "permissions:%s"

// è·å–ç”¨æˆ·æƒé™ï¼ˆå…ˆæŸ¥å†…å­˜ â†’ å†æŸ¥ Redis â†’ æœ€åæŸ¥ DBï¼‰
func GetUserPermissions(username string) ([]string, bool) {
    // å…ˆæŸ¥æœ¬åœ° LRU ç¼“å­˜
    if perms, ok := utils.LocalCache.Get(username); ok {
        return perms, true
    }

    // å†æŸ¥ Redis
    val, err := utils.RedisClient.Get(utils.Ctx, fmt.Sprintf(permissionRedisKey, username)).Result()
    if err == nil {
        var perms []string
        _ = json.Unmarshal([]byte(val), &perms)
        utils.LocalCache.Add(username, perms) // åŠ å…¥æœ¬åœ°ç¼“å­˜
        return perms, true
    }

    return nil, false
}

// è®¾ç½®æƒé™ï¼ˆåŒæ—¶å†™å…¥ Redis å’Œæœ¬åœ°ç¼“å­˜ï¼‰
func SetUserPermissions(username string, perms []string) error {
    data, _ := json.Marshal(perms)
    utils.LocalCache.Add(username, perms)

    return utils.RedisClient.Set(utils.Ctx, fmt.Sprintf(permissionRedisKey, username), data, 5*time.Minute).Err()
}

// æ¸…é™¤ç¼“å­˜ï¼ˆç”¨äºè§’è‰²æƒé™å˜æ›´æ—¶ï¼‰
func ClearUserPermissionCache(username string) {
    utils.LocalCache.Remove(username)
    utils.RedisClient.Del(utils.Ctx, fmt.Sprintf(permissionRedisKey, username))
}
```

---

## âœ¨ ä¸­é—´ä»¶ä½¿ç”¨æ–¹å¼ä¸å˜ï¼ˆä»è°ƒç”¨ `GetUserPermissions`ï¼‰

```go
func HasPermission(requiredPerm string) gin.HandlerFunc {
    return func(c *gin.Context) {
        username, _ := c.Get("username")
        perms, ok := services.GetUserPermissions(username.(string))

        if !ok {
            c.AbortWithStatusJSON(401, gin.H{"error": "æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•"})
            return
        }

        for _, p := range perms {
            if p == requiredPerm {
                c.Next()
                return
            }
        }

        c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™æ“ä½œ"})
    }
}
```

---

# ğŸ§º äºŒã€ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å‡å°‘æ— æ•ˆæŸ¥è¯¢

## ğŸ¯ ç›®æ ‡ï¼š

é¿å…å¤§é‡ä¸å­˜åœ¨ç”¨æˆ·çš„è¯·æ±‚é¢‘ç¹ç©¿é€åˆ° Redis æˆ–æ•°æ®åº“ï¼Œé€ æˆç¼“å­˜å‡»ç©¿å’Œèµ„æºæµªè´¹ã€‚

---

## ğŸ“¦ å®‰è£… Bloom Filterï¼š

```bash
go get github.com/tylertreat/BoomFilters
```

---

## ğŸ“ æ–‡ä»¶ç»“æ„æ‰©å±•ï¼š

```
utils/
â”œâ”€â”€ bloom_filter.go
```

---

## ğŸ“„ 1. åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨ï¼ˆ`utils/bloom_filter.go`ï¼‰

```go
package utils

import (
    "github.com/tylertreat/BoomFilters"
)

var UserExistsFilter *bloomfilter.ScalableBloomFilter

func InitBloomFilter() {
    UserExistsFilter = bloomfilter.NewDefaultScalableBloomFilter(1000000, 0.01)
}
```

---

## ğŸ“„ 2. åœ¨ç”¨æˆ·æ³¨å†Œã€ç™»å½•æ—¶åŠ å…¥å¸ƒéš†è¿‡æ»¤å™¨åˆ¤æ–­

### ç”¨æˆ·æ³¨å†Œæ—¶åŠ å…¥å¸ƒéš†è¿‡æ»¤å™¨ï¼š

```go
// æ³¨å†ŒæˆåŠŸååŠ å…¥å¸ƒéš†è¿‡æ»¤å™¨
utils.UserExistsFilter.Add([]byte(username))
```

### ç™»å½•æ—¶æå‰æ‹¦æˆªæ— æ•ˆç”¨æˆ·åï¼š

```go
if !utils.UserExistsFilter.Test([]byte(input.Username)) {
    utils.ErrorResponse(c, http.StatusUnauthorized, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
    return
}
```

---

## ğŸ”„ åŒæ­¥å¸ƒéš†è¿‡æ»¤å™¨ä¸çœŸå®æ•°æ®åº“çŠ¶æ€

ä½ å¯ä»¥å®šæœŸä»æ•°æ®åº“ä¸­åŠ è½½æ‰€æœ‰ç”¨æˆ·åï¼Œé‡å»ºå¸ƒéš†è¿‡æ»¤å™¨ï¼Œç¡®ä¿å…¶å‡†ç¡®åº¦ï¼š

```go
func SyncBloomFilterFromDB(db *gorm.DB) {
    var usernames []string
    db.Model(&models.User{}).Pluck("username", &usernames)

    filter := bloomfilter.NewDefaultScalableBloomFilter(uint(len(usernames)*2), 0.01)
    for _, u := range usernames {
        filter.Add([]byte(u))
    }

    utils.UserExistsFilter = filter
}
```

ä½ å¯ä»¥åœ¨é¡¹ç›®å¯åŠ¨æ—¶æ‰§è¡Œä¸€æ¬¡ï¼Œæˆ–å®šæ—¶ä»»åŠ¡æ¯å°æ—¶æ›´æ–°ä¸€æ¬¡ã€‚

---

# ğŸ¯ æ€»ç»“ï¼šå¤šçº§ç¼“å­˜ + å¸ƒéš†è¿‡æ»¤å™¨çš„ä¼˜åŠ¿

| åŠŸèƒ½                | ä¼˜åŠ¿                                   |
| ------------------- | -------------------------------------- |
| ğŸ§© å¤šçº§ç¼“å­˜         | æå‡æ€§èƒ½ã€å®¹ç¾èƒ½åŠ›å¼ºã€æœåŠ¡é‡å¯ä¸ä¸¢æ•°æ® |
| â±ï¸ æœ¬åœ° LRU ç¼“å­˜    | æä½å»¶è¿Ÿã€é«˜å‘½ä¸­ç‡                     |
| ğŸ“¡ Redis åˆ†å¸ƒå¼ç¼“å­˜ | æ”¯æŒé›†ç¾¤éƒ¨ç½²ã€ç¼“å­˜å…±äº«                 |
| ğŸ§¹ å¸ƒéš†è¿‡æ»¤å™¨       | é˜²æ­¢ç¼“å­˜ç©¿é€ã€æ‹’ç»æ— æ•ˆç”¨æˆ·åæŸ¥è¯¢       |
| ğŸ” è‡ªåŠ¨åˆ·æ–°æœºåˆ¶     | æƒé™å˜åŒ–åç¼“å­˜è‡ªåŠ¨å¤±æ•ˆï¼Œä¸å½±å“ä¸šåŠ¡é€»è¾‘ |

---

# ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

ä½ å¯ä»¥ç»§ç»­ä¼˜åŒ–è¿™ä¸ªç³»ç»Ÿï¼š

| æ–¹å‘               | æè¿°                                     |
| ------------------ | ---------------------------------------- |
| ğŸ§ª å•å…ƒæµ‹è¯•        | å¯¹ LRUã€Redisã€Bloom Filter åš mock æµ‹è¯• |
| ğŸ“Š Prometheus ç›‘æ§ | ç»Ÿè®¡å‘½ä¸­ç‡ã€ç©¿é€ç‡ã€ç¼“å­˜æ—¶é—´ç­‰æŒ‡æ ‡       |
| ğŸ§  é€šé…ç¬¦æƒé™åŒ¹é…  | å¦‚ `post:*`â€‹, `user:delete`ï¼Œæé«˜çµæ´»æ€§  |
| ğŸ›¡ï¸ é™æµç†”æ–­        | é˜²æ­¢æ¶æ„æ”»å‡»å¯¼è‡´ç¼“å­˜è¿‡è½½                 |
| ğŸ“¦ å¤šç§Ÿæˆ·æ”¯æŒ      | æ¯ä¸ªç§Ÿæˆ·ç‹¬ç«‹ç¼“å­˜ç©ºé—´ã€éš”ç¦»æƒé™ä½“ç³»       |

---

å¦‚æœä½ å¸Œæœ›æˆ‘ç»§ç»­ä¸ºä½ æ·»åŠ è¿™äº›é«˜çº§åŠŸèƒ½ï¼ˆä¾‹å¦‚ Prometheus ç›‘æ§æ¨¡å—ã€é€šé…ç¬¦æƒé™è§£æï¼‰ï¼Œæ¬¢è¿éšæ—¶å‘Šè¯‰æˆ‘ ğŸ‘‡ æˆ‘ä¼šç»§ç»­ä¸ºä½ å®Œå–„æ•´ä¸ªæƒé™ç¼“å­˜ç³»ç»Ÿï¼

---

## ğŸ“Š ä¸€ã€ä½¿ç”¨ Prometheus ç»Ÿè®¡ç¼“å­˜å‘½ä¸­ç‡ç­‰æŒ‡æ ‡

### âœ… åŠŸèƒ½ç›®æ ‡ï¼š

- è®°å½•ç¼“å­˜å‘½ä¸­æ•°ï¼ˆLRU / Redisï¼‰
- è®°å½•ç¼“å­˜ç©¿é€æ•°ï¼ˆæœªå‘½ä¸­ä¸”æŸ¥ DBï¼‰
- æš´éœ² `/metrics` æ¥å£ä¾› Prometheus æŠ“å–

---

### ğŸ”§ å®ç°æ­¥éª¤ï¼š

#### 1. å®‰è£… Prometheus Go Clientï¼š

```bash
go get github.com/prometheus/client_golang
```

---

#### 2. åˆ›å»ºç›‘æ§æŒ‡æ ‡æ–‡ä»¶ `utils/metrics.go`

```go
package utils

import (
    "github.com/prometheus/client_golang/prometheus"
)

var (
    cacheHits = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "permission_cache_hits_total",
            Help: "Number of permission cache hits by layer (lru/redis)",
        },
        []string{"layer"},
    )

    cacheMisses = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "permission_cache_misses_total",
            Help: "Total number of permission cache misses",
        },
    )

    cachePenetrations = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "permission_cache_penetration_total",
            Help: "Number of cache penetration attempts (invalid user)",
        },
    )
)

func InitMetrics() {
    prometheus.MustRegister(cacheHits)
    prometheus.MustRegister(cacheMisses)
    prometheus.MustRegister(cachePenetrations)
}

func IncCacheHit(layer string) {
    cacheHits.WithLabelValues(layer).Inc()
}

func IncCacheMiss() {
    cacheMisses.Inc()
}

func IncPenetration() {
    cachePenetrations.Inc()
}
```

---

#### 3. åœ¨ `main.go` ä¸­æ³¨å†Œ Prometheus è·¯ç”±ï¼š

```go
import (
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

// ...

r.GET("/metrics", gin.WrapH(promhttp.Handler()))
```

---

#### 4. ä¿®æ”¹æƒé™ç¼“å­˜æœåŠ¡é€»è¾‘ï¼ŒåŠ å…¥ç›‘æ§ç»Ÿè®¡ï¼ˆ`services/permission_cache.go`ï¼‰

```go
func GetUserPermissions(username string) ([]string, bool) {
    if perms, ok := utils.LocalCache.Get(username); ok {
        utils.IncCacheHit("lru")
        return perms, true
    }

    val, err := utils.RedisClient.Get(utils.Ctx, fmt.Sprintf(permissionRedisKey, username)).Result()
    if err == nil {
        var perms []string
        _ = json.Unmarshal([]byte(val), &perms)
        utils.LocalCache.Add(username, perms)
        utils.IncCacheHit("redis")
        return perms, true
    }

    utils.IncCacheMiss()
    return nil, false
}

func ClearUserPermissionCache(username string) {
    utils.LocalCache.Remove(username)
    utils.RedisClient.Del(utils.Ctx, fmt.Sprintf(permissionRedisKey, username))
}
```

---

#### 5. ç™»å½•æ—¶æ‹¦æˆªæ— æ•ˆç”¨æˆ·åå¹¶è®°å½•ç©¿é€æ¬¡æ•°ï¼š

```go
if !utils.UserExistsFilter.Test([]byte(input.Username)) {
    utils.IncPenetration()
    utils.ErrorResponse(c, http.StatusUnauthorized, "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
    return
}
```

---

### âœ… æ•ˆæœï¼šè®¿é—® `/metrics` å¯æŸ¥çœ‹å¦‚ä¸‹æŒ‡æ ‡

```
# HELP permission_cache_hits_total Number of permission cache hits by layer (lru/redis)
# TYPE permission_cache_hits_total counter
permission_cache_hits_total{layer="lru"} 100
permission_cache_hits_total{layer="redis"} 50

# HELP permission_cache_misses_total Total number of permission cache misses
# TYPE permission_cache_misses_total counter
permission_cache_misses_total 10

# HELP permission_cache_penetration_total Number of cache penetration attempts (invalid user)
# TYPE permission_cache_penetration_total counter
permission_cache_penetration_total 3
```

---

## ğŸ§  äºŒã€é€šé…ç¬¦æƒé™åŒ¹é…ï¼ˆWildcard Permission Matchï¼‰

### âœ… åŠŸèƒ½ç›®æ ‡ï¼š

- æ”¯æŒç±»ä¼¼ `post:*`â€‹, `user:delete` çš„æƒé™ç»“æ„
- æé«˜æƒé™è¡¨è¾¾èƒ½åŠ›ï¼Œç®€åŒ–è§’è‰²é…ç½®

---

### ğŸ”§ å®ç°ä»£ç ï¼š

#### æ–‡ä»¶ï¼š`services/permission_matcher.go`

```go
package services

import (
    "strings"
)

// åŒ¹é…é€šé…ç¬¦æƒé™ï¼Œå¦‚ can(post:create, post:*) => true
func HasPermission(requiredPerm string, userPerms []string) bool {
    for _, p := range userPerms {
        if p == requiredPerm {
            return true
        }

        // å¤„ç† wildcardï¼Œå¦‚ user:* åŒ¹é… user:read, user:write
        if strings.HasSuffix(p, ":*") {
            prefix := p[:len(p)-1] // å»æ‰ *
            if strings.HasPrefix(requiredPerm, prefix) {
                return true
            }
        }
    }
    return false
}
```

---

### âœ… ç¤ºä¾‹ç”¨æ³•ï¼š

```go
if !services.HasPermission("post:edit", userPerms) {
    c.AbortWithStatusJSON(403, gin.H{"error": "æ— æƒé™æ“ä½œ"})
    return
}
```

> è‹¥ç”¨æˆ·æ‹¥æœ‰ `post:*`â€‹ æƒé™ï¼Œåˆ™å¯ä»¥è®¿é—® `post:create`â€‹, `post:edit`â€‹, `post:delete` ç­‰æ‰€æœ‰å­æƒé™ã€‚

---

## ğŸ›¡ï¸ ä¸‰ã€é™æµç†”æ–­æœºåˆ¶ï¼ˆRate Limiting + Circuit Breakerï¼‰

### âœ… åŠŸèƒ½ç›®æ ‡ï¼š

- é˜²æ­¢æ¶æ„è¯·æ±‚é¢‘ç¹ç©¿é€ç¼“å­˜å’Œæ•°æ®åº“
- è®¾ç½®å•ä½æ—¶é—´å†…æœ€å¤§è¯·æ±‚æ•°
- ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•å®ç°å¹³æ»‘é™æµ

---

### ğŸ”§ å®ç°æ–¹å¼ï¼šä½¿ç”¨ `gRPC`â€‹ æˆ– `Gin`â€‹ æ’ä»¶ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ Gin + `uber-go/ratelimit`

#### 1. å®‰è£…ä¾èµ–ï¼š

```bash
go get go.uber.org/ratelimit
```

---

#### 2. åˆ›å»ºä¸­é—´ä»¶ `middlewares/rate_limit.go`

```go
package middlewares

import (
    "time"
    "go.uber.org/ratelimit"
    "github.com/gin-gonic/gin"
)

// åˆ›å»ºä¸€ä¸ªæ¯ç§’æœ€å¤š 100 æ¬¡è¯·æ±‚çš„é™æµå™¨
var limiter = ratelimit.New(100, ratelimit.WithSlidingWindow(1*time.Second))

func RateLimit() gin.HandlerFunc {
    return func(c *gin.Context) {
        if limiter.Take() == zeroTime {
            c.AbortWithStatusJSON(429, gin.H{"error": "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•"})
            return
        }
        c.Next()
    }
}

var zeroTime time.Time
```

---

#### 3. åœ¨è·¯ç”±ä¸­å¯ç”¨é™æµï¼š

```go
r.Use(middlewares.RateLimit())
```

---

## ğŸ“¦ å››ã€å¤šç§Ÿæˆ·æ”¯æŒï¼ˆå¯é€‰é«˜çº§åŠŸèƒ½ï¼‰

å¦‚æœä½ æœ‰å¤šä¸ªå®¢æˆ·/ç»„ç»‡ï¼Œå¯ä»¥ä¸ºæ¯ä¸ªç§Ÿæˆ·å»ºç«‹ç‹¬ç«‹ç¼“å­˜ç©ºé—´ï¼š

```go
const permissionRedisKey = "permissions:%s:%s" // tenantID:username
```

åœ¨ä¸­é—´ä»¶ä¸­è¯»å–ç§Ÿæˆ· IDï¼Œå¹¶å°†æƒé™ç¼“å­˜é”®åŠ ä¸Šå‰ç¼€ã€‚è¿™èƒ½ä¿è¯ä¸åŒç§Ÿæˆ·ä¹‹é—´æƒé™éš”ç¦»ã€‚

---

## ğŸ¯ æ€»ç»“ï¼šæ–°å¢åŠŸèƒ½ä¸€è§ˆè¡¨

| åŠŸèƒ½               | æè¿°                                            |
| ------------------ | ----------------------------------------------- |
| ğŸ“Š Prometheus ç›‘æ§ | è®°å½•ç¼“å­˜å‘½ä¸­ç‡ã€ç©¿é€ç‡ã€ç¼“å­˜åˆ·æ–°æ—¶é—´ç­‰          |
| ğŸ§  é€šé…ç¬¦æƒé™åŒ¹é…  | å¦‚ `post:*`â€‹ åŒ¹é… `post:create`â€‹ã€`post:delete` |
| ğŸ›¡ï¸ é™æµç†”æ–­æœºåˆ¶    | é˜²æ­¢é«˜é¢‘æ”»å‡»ã€ç¼“å­˜å‡»ç©¿                          |
| ğŸ“¦ å¤šç§Ÿæˆ·æƒé™éš”ç¦»  | ä¸åŒç§Ÿæˆ·ç¼“å­˜å’Œæƒé™äº’ä¸å¹²æ‰°                      |

---

## ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

å¯ä»¥ç»§ç»­ï¼š

- ğŸ“Œ æ·»åŠ  JWT åˆ·æ–° Token æœºåˆ¶ï¼›
- ğŸ“ å°†æƒé™æ¨¡å‹ä» GORM ç§»æ¤åˆ° Casbinï¼ˆæ›´å¼ºå¤§çš„ RBAC åº“ï¼‰ï¼›
- ğŸ“‹ æ·»åŠ å®¡è®¡æ—¥å¿—ï¼ˆAudit Logï¼‰ï¼Œè®°å½•è°åœ¨ä»€ä¹ˆæ—¶é—´æ‰§è¡Œäº†å“ªäº›æƒé™æ“ä½œï¼›
- ğŸ§± å®ç°å®Œæ•´çš„å¤šçº§æƒé™æ ‘ï¼Œæ”¯æŒå‰ç«¯åŠ¨æ€èœå•æ¸²æŸ“ï¼›
- ğŸ§ª ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•å¥—ä»¶éªŒè¯ç¼“å­˜å‘½ä¸­ç‡ã€ç©¿é€æ£€æµ‹ç­‰åŠŸèƒ½ï¼›
